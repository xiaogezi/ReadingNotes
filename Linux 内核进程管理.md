## Linux 内核进程管理





### 进程

进程就处于执行期的程序（目标码存放在某种存储介质上）。

线程是在进程中活动的对象。

每个线程都拥有一个独立的计数器、进程栈和一组进程寄存器。

内核调度的对象是线程不是进程。

Linux 系统对线程不做特别区分，对于Linux而言，线程不是一种特殊的进程罢了。

进程提供两种虚拟机制：虚拟内存和虚拟处理器。

程序本身不是进程，进程是处于执行期的程序以及相关资源的总称。

Linux 中，通常调用 fork() 来复制一个现有进程来创建一个全新的进程。

fork() 系统调用从内核返回两次：一次返回到父进程，一次返回到新产生的子进程。



### 进程状态

TASK_RUNNING（运行） 进程是可执行的。

TASK_INTERREPTIBL（可中断）进程正在休眠（阻塞），等待条件的达成。

TASK_UNINTERREPTIBL（不可中断）除了就算是接收信号也不会被唤醒或准备投入运行外，这个状态与打断状态相同。

_TASK_TRACED 被其他进程跟踪的进程，例如通过 ptrace 对调试程序进行跟踪。

_TASK_STOPPED（停止）进程停止执行。



#### 进程上下文

可执行程序代码是进程的重要组成部分。

代码可以从一个可执行文件摘录到进程的地址空间执行。

当程序代码执行系统调用，它就陷入了内核空间，此时内核 “ 代表进程执行” 并处于进程的上下文。



#### 进程家族树

Unix 和 Linux 系统的进程间存在一个明显继承关系。

所有的进程都是 PID 为 1 的 init 进程的后代。

内核在系统启动的最后阶段启动 init 进程。

系统中每个进程必须有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。



### 进程创建

Unix系统采用 fork() 和 exec() 函数创建线程。

fork() 通过拷贝当前进程创建一个子进程，

子进程与父进程的区别仅仅在于 PID（每个进程位移）、PPID（父进程的进程号，子进程将其设置为拷贝进程的 PID）和某些资源统计量。

exec() 函数负责读取可执行文件并将其载入地址空间开始运行。



#### 写时拷贝

Linux 的 fork() 使用写时拷贝页实现。

写时拷贝是一种可以推迟甚至免除拷贝数据的技术。

内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。

只有在需要写入时，数据才会被复制，从而使进程拥有各自的拷贝。

fork() 的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。



 













